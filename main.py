from urllib import request
from flask import Flask, render_template, request
from werkzeug.utils import secure_filename
import os
import joblib
import ember
from sklearn.ensemble import RandomForestClassifier
import numpy as np
from features import PEFeatureExtractor
import pefile

#Definicion de variables globales.
#UPLOAD_FOLDER contiene la ruta donde se guarda el fichero PE.
UPLOAD_FOLDER = os.path.join(os.getcwd(), "uploads")
#PATH_CLASSIFIER contiene la ruta donde se encuentran los clasificadores.
PATH_CLASSIFIER = os.path.join(os.getcwd(), "classifiers")

#Función para importar un clasificador.
def importClassifier(file_export):
    classifier_clone = joblib.load(file_export)
    return classifier_clone

#Función para predecir un fichero, dado un clasificador.
def predictFile(model, file_data, feature_version=2):
    extractor = PEFeatureExtractor(feature_version)
    features = np.array(extractor.feature_vector(file_data), dtype=np.float32)
    return model.predict([features])[0]

#Función para predecir las probabilidades de malware y benigno de un fichero, dado un clasificador.
def predictProbaFile(model, file_data, feature_version=2):
    extractor = PEFeatureExtractor(feature_version)
    features = np.array(extractor.feature_vector(file_data), dtype=np.float32)
    probabilities = model.predict_proba([features])[0]
    for i in range(0, len(probabilities)):
        probabilities[i] = round(probabilities[i]*100, 2)
    return probabilities

#Función para predecir un fichero, dado un clasificador y un umbral.
def predictFileThreshold(model, file_data, threshold, feature_version=2):
    probabilities = predictProbaFile(model, file_data)
    return probabilities[1] >= float(threshold)

#Función que devuelve el nombre del clasificador con su extensión .pkl.
def classifierSelected(classifier,bool):
    if classifier not in ["randomForest", "kNearest", "linearDiscriminant", "logisticRegression", "neuralNet"] or not bool:
        return "randomForest.pkl"
    else:
        return classifier + ".pkl"

#Función que devuelve una cadena de caracteres del clasificador que corresponda, para mostrarlo en el fichero html.
def classifierName(classifierSelected):
    if classifierSelected == "randomForest.pkl":
        return "Random Forest"
    elif classifierSelected == "kNearest.pkl":
        return "K vecinos mas cercanos"
    elif classifierSelected == "linearDiscriminant.pkl":
        return "Analisis discriminante lineal"
    elif classifierSelected == "logisticRegression.pkl":
        return "Regresion Logistica"
    elif classifierSelected == "neuralNet.pkl":
        return "Red neuronal"
    else:
        return "invalid"

#Función que sirve para verificar si un fichero es un PE válido.
def isPefile(filename):
    try:
        pe = pefile.PE(filename)
        pe.close()
        return True
    except:
        return False


app = Flask(__name__)
app.config["UPLOAD_FOLDER"] = UPLOAD_FOLDER

#Página principal, donde hará una presentación del proyecto
@app.route('/')
def index():
    return render_template("Pagina-Principal.html")

#Página que muestra información sobre los autores del proyecto
@app.route('/about')
def about():
    return render_template("Sobre-nosotros.html")

#Página que muestra toda la información del proyecto.
@app.route('/projectinformation')
def projectInformation():
    return render_template("Sobre-el-proyecto.html")

#El metodo upload es aquel que permite al usuario cargar un fichero, y analizarlo.
@app.route('/upload', methods=["GET", "POST"])
def upload():
    if request.method == "POST":
        if "ourfile" not in request.files:
            return render_template("Analizar-fichero.html", tryAgain="Inténtelo de nuevo, seleccione un fichero por favor")
        f = request.files["ourfile"]
        #Se coge el clasificador con la extensión .pkl dependiendo de la elección del usuario.
        clfSelected = classifierSelected(request.form.get('classic'),request.form.get('switch_1'))
        #Se guarda en clfName la cadena de caracteres para mostrar el nombre del clasificador en el html.
        clfName = classifierName(clfSelected)
        #Si el usuario le da a enviar y no introduce fichero, se le muestra que introduzca un fichero.
        if f.filename == "":
            return render_template("Analizar-fichero.html", tryAgain="Inténtelo de nuevo, seleccione un fichero por favor")
        #Si la petición no contiene un nombre de clasificador válido, se le pide que seleccione un clasificador.
        if clfName == "invalid":
            return render_template("Analizar-fichero.html", tryAgain="Inténtelo de nuevo, seleccione un clasificador por favor")
        #Se asegura el nombre de fichero antes de almacenarlo.
        filename = secure_filename(f.filename)
        #Se guarda el fichero en la ruta almacenada UPLOAD_FOLDER.
        f.save(os.path.join(app.config["UPLOAD_FOLDER"], filename))
        
        #Si ha subido un fichero el usuario y es un PE valido, se comienzan los siguientes pasos.
        if f and isPefile(os.path.join(app.config["UPLOAD_FOLDER"], filename)):
            #Se cargan los bytes del fichero.
            file_to_predict = open(os.path.join(
                app.config["UPLOAD_FOLDER"], filename), "rb").read()
            # Se elimina el fichero de la ruta UPLOAD_FOLDER.
            os.remove(os.path.join(app.config["UPLOAD_FOLDER"], filename))
            
            # COMIENZA EL ANÁLISIS DEL FICHERO.
            # En primer lugar, se importa el clasificador seleccionado por el usuario.
            clf = importClassifier(os.path.join(
                PATH_CLASSIFIER, clfSelected))
            # Comprobacion de si ha seleccionado un umbral el usuario.
            if request.form.get('threshold') != "" and request.form.get('switch_2'):
                # Si se ha seleccionado un umbral, se predice con dicho umbrel.
                threshold = request.form.get('threshold')
                result = predictFileThreshold(clf, file_to_predict, threshold)
                probabilities = predictProbaFile(clf, file_to_predict)
                #Si devuelve verdadero, será que es malware, por el contrario si devuelve falso es que es benigno.
                if result:
                    return render_template("Malware.html", classifierName=clfName, probBening=str(probabilities[0])+"%", probMalware=str(probabilities[1])+"%")
                else:
                    return render_template("Benigno.html", classifierName=clfName, probBening=str(probabilities[0])+"%", probMalware=str(probabilities[1])+"%")
            else:
                # si no se selecciona un umbral, se predice normal.
                result = predictFile(clf, file_to_predict)
                probabilities = predictProbaFile(clf, file_to_predict)
                # Si la prediccion devuelve 0, se mostrará la pantalla de benigno, si devuelve 1 la de malware.
                if result == 0.0:
                    return render_template("Benigno.html", classifierName=clfName, probBening=str(probabilities[0])+"%", probMalware=str(probabilities[1])+"%")
                else:
                    return render_template("Malware.html", classifierName=clfName, probBening=str(probabilities[0])+"%", probMalware=str(probabilities[1])+"%")
        #Si el fichero no es un PE válido, se borra y se le muestra que no es un fichero no permitido.
        os.remove(os.path.join(app.config["UPLOAD_FOLDER"], filename))
        return render_template("Analizar-fichero.html", tryAgain="Inténtelo de nuevo, fichero no permitido, recuerde solo PE ejecutables")
    return render_template("Analizar-fichero.html")


if __name__ == '__main__':
    #app.run(host='0.0.0.0')
    app.run()
